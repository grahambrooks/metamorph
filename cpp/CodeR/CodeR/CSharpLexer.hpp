/** \file
 *  This C++ header file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : CSharp.g
 *     -                            On : 2012-09-04 22:52:45
 *     -                 for the lexer : CSharpLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
 * The lexer 
CSharpLexer

has the callable functions (rules) shown below,
 * which will invoke the code for the associated rule in the source grammar
 * assuming that the input stream is pointing to a token/text stream that could begin
 * this rule.
 *
 * For instance if you call the first (topmost) rule in a parser grammar, you will
 * get the results of a full parse, but calling a rule half way through the grammar will
 * allow you to pass part of a full token stream to the parser, such as for syntax checking
 * in editors and so on.
 *
 */
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram. 
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef	_CSharpLexer_H
#define _CSharpLexer_H
/* =============================================================================
 * Standard antlr3 C++ runtime definitions
 */
#include    <antlr3.hpp>

/* End of standard antlr 3 runtime definitions
 * =============================================================================
 */




#include <string>
#include <map>
#include <stack>
using namespace::std;



#ifdef	WIN32
// Disable: Unreferenced parameter,							- Rules with parameters that are not used
//          constant conditional,							- ANTLR realizes that a prediction is always true (synpred usually)
//          initialized but unused variable					- tree rewrite variables declared but not needed
//          Unreferenced local variable						- lexer rule declares but does not always use _type
//          potentially unitialized variable used			- retval always returned from a rule
//			unreferenced local function has been removed	- susually getTokenNames or freeScope, they can go without warnigns
//
// These are only really displayed at warning level /W4 but that is the code ideal I am aiming at
// and the codegen must generate some of these warnings by necessity, apart from 4100, which is
// usually generated when a parser rule is given a parameter that it does not use. Mostly though
// this is a matter of orthogonality hence I disable that one.
//
#pragma warning( disable : 4100 )
#pragma warning( disable : 4101 )
#pragma warning( disable : 4127 )
#pragma warning( disable : 4189 )
#pragma warning( disable : 4505 )
#pragma warning( disable : 4701 )
#endif
	namespace  CodeR  {



	class CSharpLexer; 
	class CSharpParser; 

//	template<class ImplTraits>
//	class CodeRTraits : public antlr3::CustomTraitsBase<ImplTraits>
//	{
//	public:
//	    //for using the token stream which deleted the tokens, once it is reduced to a rule
//		//but it leaves the start and stop tokens. So they can be accessed as usual
//		static const bool TOKENS_ACCESSED_FROM_OWNING_RULE = true;
//	};
//
//	typedef antlr3::Traits< CSharpLexer, CSharpParser, CodeRTraits > CSharpLexerTraits;
//	typedef CSharpLexerTraits CSharpParserTraits;

	/* If you don't want the override it is like this.
	   class TLexer;
	   class TParser;
	   typedef antlr3::Traits< TLexer, TParser > TLexerTraits;
	   typedef TLexerTraits TParserTraits;
	 */
typedef antlr3::Traits< CSharpLexer, CSharpParser > CSharpLexerTraits;
typedef CSharpLexerTraits CSharpParserTraits;

typedef CSharpLexerTraits CSharpLexerImplTraits;


class CSharpLexerTokens
{
public:
	/** Symbolic definitions of all the tokens that the 
lexer
 will work with.
	 * \{
	 *
	 * Antlr will define EOF, but we can't use that as it it is too common in
	 * in C header files and that would be confusing. There is no way to filter this out at the moment
	 * so we just undef it here for now. That isn't the value we get back from C recognizers
	 * anyway. We are looking for ANTLR_TOKEN_EOF.
	 */
	enum Tokens 
	{
		EOF_TOKEN = CSharpLexerImplTraits::CommonTokenType::TOKEN_EOF
		, T__64 = 64 
		, T__65 = 65 
		, T__66 = 66 
		, T__67 = 67 
		, T__68 = 68 
		, T__69 = 69 
		, T__70 = 70 
		, T__71 = 71 
		, T__72 = 72 
		, T__73 = 73 
		, T__74 = 74 
		, T__75 = 75 
		, T__76 = 76 
		, T__77 = 77 
		, T__78 = 78 
		, T__79 = 79 
		, T__80 = 80 
		, T__81 = 81 
		, T__82 = 82 
		, T__83 = 83 
		, T__84 = 84 
		, T__85 = 85 
		, T__86 = 86 
		, T__87 = 87 
		, T__88 = 88 
		, T__89 = 89 
		, T__90 = 90 
		, T__91 = 91 
		, T__92 = 92 
		, T__93 = 93 
		, T__94 = 94 
		, T__95 = 95 
		, T__96 = 96 
		, T__97 = 97 
		, T__98 = 98 
		, T__99 = 99 
		, T__100 = 100 
		, T__101 = 101 
		, T__102 = 102 
		, T__103 = 103 
		, T__104 = 104 
		, T__105 = 105 
		, T__106 = 106 
		, T__107 = 107 
		, T__108 = 108 
		, T__109 = 109 
		, T__110 = 110 
		, T__111 = 111 
		, T__112 = 112 
		, T__113 = 113 
		, T__114 = 114 
		, T__115 = 115 
		, T__116 = 116 
		, T__117 = 117 
		, T__118 = 118 
		, T__119 = 119 
		, T__120 = 120 
		, T__121 = 121 
		, T__122 = 122 
		, T__123 = 123 
		, T__124 = 124 
		, T__125 = 125 
		, T__126 = 126 
		, T__127 = 127 
		, T__128 = 128 
		, T__129 = 129 
		, T__130 = 130 
		, T__131 = 131 
		, T__132 = 132 
		, T__133 = 133 
		, T__134 = 134 
		, T__135 = 135 
		, T__136 = 136 
		, T__137 = 137 
		, T__138 = 138 
		, T__139 = 139 
		, T__140 = 140 
		, T__141 = 141 
		, T__142 = 142 
		, T__143 = 143 
		, T__144 = 144 
		, T__145 = 145 
		, T__146 = 146 
		, T__147 = 147 
		, T__148 = 148 
		, T__149 = 149 
		, T__150 = 150 
		, T__151 = 151 
		, T__152 = 152 
		, T__153 = 153 
		, T__154 = 154 
		, T__155 = 155 
		, T__156 = 156 
		, T__157 = 157 
		, T__158 = 158 
		, T__159 = 159 
		, T__160 = 160 
		, T__161 = 161 
		, T__162 = 162 
		, T__163 = 163 
		, T__164 = 164 
		, T__165 = 165 
		, T__166 = 166 
		, T__167 = 167 
		, T__168 = 168 
		, T__169 = 169 
		, T__170 = 170 
		, T__171 = 171 
		, T__172 = 172 
		, T__173 = 173 
		, T__174 = 174 
		, T__175 = 175 
		, T__176 = 176 
		, T__177 = 177 
		, T__178 = 178 
		, T__179 = 179 
		, T__180 = 180 
		, T__181 = 181 
		, T__182 = 182 
		, T__183 = 183 
		, T__184 = 184 
		, T__185 = 185 
		, T__186 = 186 
		, T__187 = 187 
		, T__188 = 188 
		, T__189 = 189 
		, T__190 = 190 
		, T__191 = 191 
		, T__192 = 192 
		, T__193 = 193 
		, T__194 = 194 
		, T__195 = 195 
		, T__196 = 196 
		, T__197 = 197 
		, T__198 = 198 
		, T__199 = 199 
		, T__200 = 200 
		, T__201 = 201 
		, T__202 = 202 
		, T__203 = 203 
		, T__204 = 204 
		, CATCH = 4 
		, CLASS_DECL = 5 
		, COMMENT = 6 
		, Character_literal = 7 
		, DECIMAL_DIGIT = 8 
		, DEFINE = 9 
		, DEFINE_TOKEN = 10 
		, DOC_LINE_COMMENT = 11 
		, DOT = 12 
		, Decimal_digits = 13 
		, Decimal_integer_literal = 14 
		, ELIF = 15 
		, ELSE_TOKEN = 16 
		, ENDIF = 17 
		, ENDIF_TOKEN = 18 
		, ENUM = 19 
		, EscapeSequence = 20 
		, Exponent_part = 21 
		, FALSE = 22 
		, GT = 23 
		, GooBall = 24 
		, GooBallIdentifier = 25 
		, HEX_DIGIT = 26 
		, HEX_DIGITS = 27 
		, Hex_number = 28 
		, IDENTIFIER = 29 
		, IF = 30 
		, IF_TOKEN = 31 
		, INTEGER_TYPE_SUFFIX = 32 
		, IdentifierPart = 33 
		, IdentifierStart = 34 
		, LINE_COMMENT = 35 
		, LT_NULL = 36 
		, MINUS = 37 
		, NUMBER = 38 
		, PP_AND_EXPRESSION = 39 
		, PP_CONDITIONAL = 40 
		, PP_EQUALITY_EXPRESSION = 41 
		, PP_EXPRESSION = 42 
		, PP_OR_EXPRESSION = 43 
		, PP_PRIMARY_EXPRESSION = 44 
		, PP_UNARY_EXPRESSION = 45 
		, PREPROCESSOR_DIRECTIVE = 46 
		, PTR = 47 
		, Pragma = 48 
		, RPAREN = 49 
		, Real_literal = 50 
		, Real_type_suffix = 51 
		, SEMI = 52 
		, STRINGLITERAL = 53 
		, Sign = 54 
		, TRUE = 55 
		, TS = 56 
		, UNDEF = 57 
		, UNDEF_TOKEN = 58 
		, USING = 59 
		, VARIABLE_DECL = 60 
		, Verbatim_string_literal = 61 
		, Verbatim_string_literal_character = 62 
		, WS = 63 
	};

};

/** Context tracking structure for 
CSharpLexer

 */
class CSharpLexer : public 
CSharpLexerImplTraits::BaseLexerType
, public CSharpLexerTokens
{
public:
	typedef CSharpLexerImplTraits ImplTraits;
	typedef CSharpLexer ComponentType;
	typedef ComponentType::StreamType StreamType;
	typedef 
CSharpLexerImplTraits::BaseLexerType
 BaseType;
	typedef ImplTraits::RecognizerSharedStateType<StreamType> RecognizerSharedStateType;
	typedef StreamType InputType;
	static const bool IsFiltered = false;


private:	
public:
    CSharpLexer(InputType* instream);
    CSharpLexer(InputType* instream, RecognizerSharedStateType* state);

    void init(InputType* instream  );

    
     void
      mCATCH( );

     void
      mT__64( );

     void
      mT__65( );

     void
      mT__66( );

     void
      mT__67( );

     void
      mT__68( );

     void
      mT__69( );

     void
      mT__70( );

     void
      mT__71( );

     void
      mT__72( );

     void
      mT__73( );

     void
      mT__74( );

     void
      mT__75( );

     void
      mT__76( );

     void
      mT__77( );

     void
      mT__78( );

     void
      mT__79( );

     void
      mT__80( );

     void
      mT__81( );

     void
      mT__82( );

     void
      mT__83( );

     void
      mT__84( );

     void
      mT__85( );

     void
      mT__86( );

     void
      mT__87( );

     void
      mT__88( );

     void
      mT__89( );

     void
      mT__90( );

     void
      mT__91( );

     void
      mT__92( );

     void
      mT__93( );

     void
      mT__94( );

     void
      mT__95( );

     void
      mT__96( );

     void
      mT__97( );

     void
      mT__98( );

     void
      mT__99( );

     void
      mT__100( );

     void
      mT__101( );

     void
      mT__102( );

     void
      mT__103( );

     void
      mT__104( );

     void
      mT__105( );

     void
      mT__106( );

     void
      mT__107( );

     void
      mT__108( );

     void
      mT__109( );

     void
      mT__110( );

     void
      mT__111( );

     void
      mT__112( );

     void
      mT__113( );

     void
      mT__114( );

     void
      mT__115( );

     void
      mT__116( );

     void
      mT__117( );

     void
      mT__118( );

     void
      mT__119( );

     void
      mT__120( );

     void
      mT__121( );

     void
      mT__122( );

     void
      mT__123( );

     void
      mT__124( );

     void
      mT__125( );

     void
      mT__126( );

     void
      mT__127( );

     void
      mT__128( );

     void
      mT__129( );

     void
      mT__130( );

     void
      mT__131( );

     void
      mT__132( );

     void
      mT__133( );

     void
      mT__134( );

     void
      mT__135( );

     void
      mT__136( );

     void
      mT__137( );

     void
      mT__138( );

     void
      mT__139( );

     void
      mT__140( );

     void
      mT__141( );

     void
      mT__142( );

     void
      mT__143( );

     void
      mT__144( );

     void
      mT__145( );

     void
      mT__146( );

     void
      mT__147( );

     void
      mT__148( );

     void
      mT__149( );

     void
      mT__150( );

     void
      mT__151( );

     void
      mT__152( );

     void
      mT__153( );

     void
      mT__154( );

     void
      mT__155( );

     void
      mT__156( );

     void
      mT__157( );

     void
      mT__158( );

     void
      mT__159( );

     void
      mT__160( );

     void
      mT__161( );

     void
      mT__162( );

     void
      mT__163( );

     void
      mT__164( );

     void
      mT__165( );

     void
      mT__166( );

     void
      mT__167( );

     void
      mT__168( );

     void
      mT__169( );

     void
      mT__170( );

     void
      mT__171( );

     void
      mT__172( );

     void
      mT__173( );

     void
      mT__174( );

     void
      mT__175( );

     void
      mT__176( );

     void
      mT__177( );

     void
      mT__178( );

     void
      mT__179( );

     void
      mT__180( );

     void
      mT__181( );

     void
      mT__182( );

     void
      mT__183( );

     void
      mT__184( );

     void
      mT__185( );

     void
      mT__186( );

     void
      mT__187( );

     void
      mT__188( );

     void
      mT__189( );

     void
      mT__190( );

     void
      mT__191( );

     void
      mT__192( );

     void
      mT__193( );

     void
      mT__194( );

     void
      mT__195( );

     void
      mT__196( );

     void
      mT__197( );

     void
      mT__198( );

     void
      mT__199( );

     void
      mT__200( );

     void
      mT__201( );

     void
      mT__202( );

     void
      mT__203( );

     void
      mT__204( );

     void
      mTRUE( );

     void
      mFALSE( );

     void
      mLT_NULL( );

     void
      mDOT( );

     void
      mPTR( );

     void
      mMINUS( );

     void
      mGT( );

     void
      mUSING( );

     void
      mENUM( );

     void
      mIF( );

     void
      mELIF( );

     void
      mENDIF( );

     void
      mDEFINE( );

     void
      mUNDEF( );

     void
      mSEMI( );

     void
      mRPAREN( );

     void
      mWS( );

     void
      mTS( );

     void
      mDOC_LINE_COMMENT( );

     void
      mLINE_COMMENT( );

     void
      mCOMMENT( );

     void
      mSTRINGLITERAL( );

     void
      mVerbatim_string_literal( );

     void
      mVerbatim_string_literal_character( );

     void
      mNUMBER( );

     void
      mGooBall( );

     void
      mGooBallIdentifier( );

     void
      mReal_literal( );

     void
      mCharacter_literal( );

     void
      mIDENTIFIER( );

     void
      mPragma( );

     void
      mPREPROCESSOR_DIRECTIVE( );

     void
      mPP_CONDITIONAL( );

     void
      mIF_TOKEN( );

     void
      mDEFINE_TOKEN( );

     void
      mUNDEF_TOKEN( );

     void
      mELSE_TOKEN( );

     void
      mENDIF_TOKEN( );

     void
      mPP_EXPRESSION( );

     void
      mPP_OR_EXPRESSION( );

     void
      mPP_AND_EXPRESSION( );

     void
      mPP_EQUALITY_EXPRESSION( );

     void
      mPP_UNARY_EXPRESSION( );

     void
      mPP_PRIMARY_EXPRESSION( );

     void
      mIdentifierStart( );

     void
      mIdentifierPart( );

     void
      mEscapeSequence( );

     void
      mDecimal_integer_literal( );

     void
      mHex_number( );

     void
      mDecimal_digits( );

     void
      mDECIMAL_DIGIT( );

     void
      mINTEGER_TYPE_SUFFIX( );

     void
      mHEX_DIGITS( );

     void
      mHEX_DIGIT( );

     void
      mExponent_part( );

     void
      mSign( );

     void
      mReal_type_suffix( );

     void
      mTokens( );
    const char *    getGrammarFileName();
    void            reset();
    ~CSharpLexer();

};

// Function protoypes for the constructor functions that external translation units
// such as delegators and delegates may wish to call.
//

/* End of token definitions for CSharpLexer
 * =============================================================================
 */
/** } */

	}


#endif

/* END - Note:Keep extra line feed to satisfy UNIX systems */
